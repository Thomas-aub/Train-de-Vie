{"ast":null,"code":"'use strict';\n\nvar _inherits = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _createClass = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar NOOP = function NOOP() {};\n\nvar removeWhere = function removeWhere(list, predicate) {\n  var i = list.findIndex(predicate);\n  return i === -1 ? undefined : list.splice(i, 1)[0];\n};\n\nvar IdleItem = /*#__PURE__*/_createClass(function IdleItem(client, idleListener, timeoutId) {\n  _classCallCheck(this, IdleItem);\n\n  this.client = client;\n  this.idleListener = idleListener;\n  this.timeoutId = timeoutId;\n});\n\nvar PendingItem = /*#__PURE__*/_createClass(function PendingItem(callback) {\n  _classCallCheck(this, PendingItem);\n\n  this.callback = callback;\n});\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.');\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return {\n      callback: callback,\n      result: undefined\n    };\n  }\n\n  var rej;\n  var res;\n\n  var cb = function cb(err, client) {\n    err ? rej(err) : res(client);\n  };\n\n  var result = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    callback: cb,\n    result: result\n  };\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client;\n    client.removeListener('error', idleListener);\n    client.on('error', function () {\n      pool.log('additional client error after disconnection due to error', err);\n    });\n\n    pool._remove(client); // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n\n\n    pool.emit('error', err, client);\n  };\n}\n\nvar Pool = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Pool, _EventEmitter);\n\n  var _super = _createSuper(Pool);\n\n  function Pool(options, Client) {\n    var _this;\n\n    _classCallCheck(this, Pool);\n\n    _this = _super.call(this);\n    _this.options = Object.assign({}, options);\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(_this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password\n      });\n    }\n\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(_this.options.ssl, 'key', {\n        enumerable: false\n      });\n    }\n\n    _this.options.max = _this.options.max || _this.options.poolSize || 10;\n    _this.options.maxUses = _this.options.maxUses || Infinity;\n    _this.options.allowExitOnIdle = _this.options.allowExitOnIdle || false;\n    _this.options.maxLifetimeSeconds = _this.options.maxLifetimeSeconds || 0;\n\n    _this.log = _this.options.log || function () {};\n\n    _this.Client = _this.options.Client || Client || require('pg').Client;\n    _this.Promise = _this.options.Promise || global.Promise;\n\n    if (typeof _this.options.idleTimeoutMillis === 'undefined') {\n      _this.options.idleTimeoutMillis = 10000;\n    }\n\n    _this._clients = [];\n    _this._idle = [];\n    _this._expired = new WeakSet();\n    _this._pendingQueue = [];\n    _this._endCallback = undefined;\n    _this.ending = false;\n    _this.ended = false;\n    return _this;\n  }\n\n  _createClass(Pool, [{\n    key: \"_isFull\",\n    value: function _isFull() {\n      return this._clients.length >= this.options.max;\n    }\n  }, {\n    key: \"_pulseQueue\",\n    value: function _pulseQueue() {\n      var _this2 = this;\n\n      this.log('pulse queue');\n\n      if (this.ended) {\n        this.log('pulse queue ended');\n        return;\n      }\n\n      if (this.ending) {\n        this.log('pulse queue on ending');\n\n        if (this._idle.length) {\n          this._idle.slice().map(function (item) {\n            _this2._remove(item.client);\n          });\n        }\n\n        if (!this._clients.length) {\n          this.ended = true;\n\n          this._endCallback();\n        }\n\n        return;\n      } // if we don't have any waiting, do nothing\n\n\n      if (!this._pendingQueue.length) {\n        this.log('no queued requests');\n        return;\n      } // if we don't have any idle clients and we have no more room do nothing\n\n\n      if (!this._idle.length && this._isFull()) {\n        return;\n      }\n\n      var pendingItem = this._pendingQueue.shift();\n\n      if (this._idle.length) {\n        var idleItem = this._idle.pop();\n\n        clearTimeout(idleItem.timeoutId);\n        var client = idleItem.client;\n        client.ref && client.ref();\n        var idleListener = idleItem.idleListener;\n        return this._acquireClient(client, pendingItem, idleListener, false);\n      }\n\n      if (!this._isFull()) {\n        return this.newClient(pendingItem);\n      }\n\n      throw new Error('unexpected condition');\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove(client) {\n      var removed = removeWhere(this._idle, function (item) {\n        return item.client === client;\n      });\n\n      if (removed !== undefined) {\n        clearTimeout(removed.timeoutId);\n      }\n\n      this._clients = this._clients.filter(function (c) {\n        return c !== client;\n      });\n      client.end();\n      this.emit('remove', client);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(cb) {\n      var _this3 = this;\n\n      if (this.ending) {\n        var err = new Error('Cannot use a pool after calling end on the pool');\n        return cb ? cb(err) : this.Promise.reject(err);\n      }\n\n      var response = promisify(this.Promise, cb);\n      var result = response.result; // if we don't have to connect a new client, don't do so\n\n      if (this._isFull() || this._idle.length) {\n        // if we have idle clients schedule a pulse immediately\n        if (this._idle.length) {\n          process.nextTick(function () {\n            return _this3._pulseQueue();\n          });\n        }\n\n        if (!this.options.connectionTimeoutMillis) {\n          this._pendingQueue.push(new PendingItem(response.callback));\n\n          return result;\n        }\n\n        var queueCallback = function queueCallback(err, res, done) {\n          clearTimeout(tid);\n          response.callback(err, res, done);\n        };\n\n        var pendingItem = new PendingItem(queueCallback); // set connection timeout on checking out an existing client\n\n        var tid = setTimeout(function () {\n          // remove the callback from pending waiters because\n          // we're going to call it with a timeout error\n          removeWhere(_this3._pendingQueue, function (i) {\n            return i.callback === queueCallback;\n          });\n          pendingItem.timedOut = true;\n          response.callback(new Error('timeout exceeded when trying to connect'));\n        }, this.options.connectionTimeoutMillis);\n\n        this._pendingQueue.push(pendingItem);\n\n        return result;\n      }\n\n      this.newClient(new PendingItem(response.callback));\n      return result;\n    }\n  }, {\n    key: \"newClient\",\n    value: function newClient(pendingItem) {\n      var _this4 = this;\n\n      var client = new this.Client(this.options);\n\n      this._clients.push(client);\n\n      var idleListener = makeIdleListener(this, client);\n      this.log('checking client timeout'); // connection timeout logic\n\n      var tid;\n      var timeoutHit = false;\n\n      if (this.options.connectionTimeoutMillis) {\n        tid = setTimeout(function () {\n          _this4.log('ending client due to timeout');\n\n          timeoutHit = true; // force kill the node driver, and let libpq do its teardown\n\n          client.connection ? client.connection.stream.destroy() : client.end();\n        }, this.options.connectionTimeoutMillis);\n      }\n\n      this.log('connecting new client');\n      client.connect(function (err) {\n        if (tid) {\n          clearTimeout(tid);\n        }\n\n        client.on('error', idleListener);\n\n        if (err) {\n          _this4.log('client failed to connect', err); // remove the dead client from our list of clients\n\n\n          _this4._clients = _this4._clients.filter(function (c) {\n            return c !== client;\n          });\n\n          if (timeoutHit) {\n            err.message = 'Connection terminated due to connection timeout';\n          } // this client wonâ€™t be released, so move on immediately\n\n\n          _this4._pulseQueue();\n\n          if (!pendingItem.timedOut) {\n            pendingItem.callback(err, undefined, NOOP);\n          }\n        } else {\n          _this4.log('new client connected');\n\n          if (_this4.options.maxLifetimeSeconds !== 0) {\n            var maxLifetimeTimeout = setTimeout(function () {\n              _this4.log('ending client due to expired lifetime');\n\n              _this4._expired.add(client);\n\n              var idleIndex = _this4._idle.findIndex(function (idleItem) {\n                return idleItem.client === client;\n              });\n\n              if (idleIndex !== -1) {\n                _this4._acquireClient(client, new PendingItem(function (err, client, clientRelease) {\n                  return clientRelease();\n                }), idleListener, false);\n              }\n            }, _this4.options.maxLifetimeSeconds * 1000);\n            maxLifetimeTimeout.unref();\n            client.once('end', function () {\n              return clearTimeout(maxLifetimeTimeout);\n            });\n          }\n\n          return _this4._acquireClient(client, pendingItem, idleListener, true);\n        }\n      });\n    } // acquire a client for a pending work item\n\n  }, {\n    key: \"_acquireClient\",\n    value: function _acquireClient(client, pendingItem, idleListener, isNew) {\n      if (isNew) {\n        this.emit('connect', client);\n      }\n\n      this.emit('acquire', client);\n      client.release = this._releaseOnce(client, idleListener);\n      client.removeListener('error', idleListener);\n\n      if (!pendingItem.timedOut) {\n        if (isNew && this.options.verify) {\n          this.options.verify(client, function (err) {\n            if (err) {\n              client.release(err);\n              return pendingItem.callback(err, undefined, NOOP);\n            }\n\n            pendingItem.callback(undefined, client, client.release);\n          });\n        } else {\n          pendingItem.callback(undefined, client, client.release);\n        }\n      } else {\n        if (isNew && this.options.verify) {\n          this.options.verify(client, client.release);\n        } else {\n          client.release();\n        }\n      }\n    } // returns a function that wraps _release and throws if called more than once\n\n  }, {\n    key: \"_releaseOnce\",\n    value: function _releaseOnce(client, idleListener) {\n      var _this5 = this;\n\n      var released = false;\n      return function (err) {\n        if (released) {\n          throwOnDoubleRelease();\n        }\n\n        released = true;\n\n        _this5._release(client, idleListener, err);\n      };\n    } // release a client back to the poll, include an error\n    // to remove it from the pool\n\n  }, {\n    key: \"_release\",\n    value: function _release(client, idleListener, err) {\n      var _this6 = this;\n\n      client.on('error', idleListener);\n      client._poolUseCount = (client._poolUseCount || 0) + 1; // TODO(bmc): expose a proper, public interface _queryable and _ending\n\n      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n        if (client._poolUseCount >= this.options.maxUses) {\n          this.log('remove expended client');\n        }\n\n        this._remove(client);\n\n        this._pulseQueue();\n\n        return;\n      }\n\n      var isExpired = this._expired.has(client);\n\n      if (isExpired) {\n        this.log('remove expired client');\n\n        this._expired.delete(client);\n\n        this._remove(client);\n\n        this._pulseQueue();\n\n        return;\n      } // idle timeout\n\n\n      var tid;\n\n      if (this.options.idleTimeoutMillis) {\n        tid = setTimeout(function () {\n          _this6.log('remove idle client');\n\n          _this6._remove(client);\n        }, this.options.idleTimeoutMillis);\n\n        if (this.options.allowExitOnIdle) {\n          // allow Node to exit if this is all that's left\n          tid.unref();\n        }\n      }\n\n      if (this.options.allowExitOnIdle) {\n        client.unref();\n      }\n\n      this._idle.push(new IdleItem(client, idleListener, tid));\n\n      this._pulseQueue();\n    }\n  }, {\n    key: \"query\",\n    value: function query(text, values, cb) {\n      var _this7 = this;\n\n      // guard clause against passing a function as the first parameter\n      if (typeof text === 'function') {\n        var _response = promisify(this.Promise, text);\n\n        setImmediate(function () {\n          return _response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));\n        });\n        return _response.result;\n      } // allow plain text query without values\n\n\n      if (typeof values === 'function') {\n        cb = values;\n        values = undefined;\n      }\n\n      var response = promisify(this.Promise, cb);\n      cb = response.callback;\n      this.connect(function (err, client) {\n        if (err) {\n          return cb(err);\n        }\n\n        var clientReleased = false;\n\n        var onError = function onError(err) {\n          if (clientReleased) {\n            return;\n          }\n\n          clientReleased = true;\n          client.release(err);\n          cb(err);\n        };\n\n        client.once('error', onError);\n\n        _this7.log('dispatching query');\n\n        try {\n          client.query(text, values, function (err, res) {\n            _this7.log('query dispatched');\n\n            client.removeListener('error', onError);\n\n            if (clientReleased) {\n              return;\n            }\n\n            clientReleased = true;\n            client.release(err);\n\n            if (err) {\n              return cb(err);\n            }\n\n            return cb(undefined, res);\n          });\n        } catch (err) {\n          client.release(err);\n          return cb(err);\n        }\n      });\n      return response.result;\n    }\n  }, {\n    key: \"end\",\n    value: function end(cb) {\n      this.log('ending');\n\n      if (this.ending) {\n        var err = new Error('Called end on pool more than once');\n        return cb ? cb(err) : this.Promise.reject(err);\n      }\n\n      this.ending = true;\n      var promised = promisify(this.Promise, cb);\n      this._endCallback = promised.callback;\n\n      this._pulseQueue();\n\n      return promised.result;\n    }\n  }, {\n    key: \"waitingCount\",\n    get: function get() {\n      return this._pendingQueue.length;\n    }\n  }, {\n    key: \"idleCount\",\n    get: function get() {\n      return this._idle.length;\n    }\n  }, {\n    key: \"expiredCount\",\n    get: function get() {\n      var _this8 = this;\n\n      return this._clients.reduce(function (acc, client) {\n        return acc + (_this8._expired.has(client) ? 1 : 0);\n      }, 0);\n    }\n  }, {\n    key: \"totalCount\",\n    get: function get() {\n      return this._clients.length;\n    }\n  }]);\n\n  return Pool;\n}(EventEmitter);\n\nmodule.exports = Pool;","map":{"version":3,"names":["EventEmitter","require","NOOP","removeWhere","list","predicate","i","findIndex","undefined","splice","IdleItem","client","idleListener","timeoutId","PendingItem","callback","throwOnDoubleRelease","Error","promisify","Promise","result","rej","res","cb","err","resolve","reject","makeIdleListener","pool","removeListener","on","log","_remove","emit","Pool","options","Client","Object","assign","defineProperty","configurable","enumerable","writable","value","password","ssl","key","max","poolSize","maxUses","Infinity","allowExitOnIdle","maxLifetimeSeconds","global","idleTimeoutMillis","_clients","_idle","_expired","WeakSet","_pendingQueue","_endCallback","ending","ended","length","slice","map","item","_isFull","pendingItem","shift","idleItem","pop","clearTimeout","ref","_acquireClient","newClient","removed","filter","c","end","response","process","nextTick","_pulseQueue","connectionTimeoutMillis","push","queueCallback","done","tid","setTimeout","timedOut","timeoutHit","connection","stream","destroy","connect","message","maxLifetimeTimeout","add","idleIndex","clientRelease","unref","once","isNew","release","_releaseOnce","verify","released","_release","_poolUseCount","_queryable","_ending","isExpired","has","delete","text","values","setImmediate","clientReleased","onError","query","promised","reduce","acc","module","exports"],"sources":["C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/pg-pool/index.js"],"sourcesContent":["'use strict'\nconst EventEmitter = require('events').EventEmitter\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || require('pg').Client\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    client.end()\n    this.emit('remove', client)\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout'\n        }\n\n        // this client wonâ€™t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client)\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}