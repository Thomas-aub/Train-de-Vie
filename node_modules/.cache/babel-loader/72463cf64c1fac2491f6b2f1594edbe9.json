{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar net = require('net');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar _require = require('pg-protocol'),\n    parse = _require.parse,\n    serialize = _require.serialize;\n\nvar flushBuffer = serialize.flush();\nvar syncBuffer = serialize.sync();\nvar endBuffer = serialize.end(); // TODO(bmc) support binary mode at some point\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  var _super = _createSuper(Connection);\n\n  function Connection(config) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _super.call(this);\n    config = config || {};\n    _this.stream = config.stream || new net.Socket();\n    _this._keepAlive = config.keepAlive;\n    _this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n    _this.lastBuffer = false;\n    _this.parsedStatements = {};\n    _this.ssl = config.ssl || false;\n    _this._ending = false;\n    _this._emitMessage = false;\n\n    var self = _assertThisInitialized(_this);\n\n    _this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true;\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"connect\",\n    value: function connect(port, host) {\n      var self = this;\n      this._connecting = true;\n      this.stream.setNoDelay(true);\n      this.stream.connect(port, host);\n      this.stream.once('connect', function () {\n        if (self._keepAlive) {\n          self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n        }\n\n        self.emit('connect');\n      });\n\n      var reportStreamError = function reportStreamError(error) {\n        // errors about disconnections should be ignored during disconnect\n        if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n          return;\n        }\n\n        self.emit('error', error);\n      };\n\n      this.stream.on('error', reportStreamError);\n      this.stream.on('close', function () {\n        self.emit('end');\n      });\n\n      if (!this.ssl) {\n        return this.attachListeners(this.stream);\n      }\n\n      this.stream.once('data', function (buffer) {\n        var responseCode = buffer.toString('utf8');\n\n        switch (responseCode) {\n          case 'S':\n            // Server supports SSL connections, continue with a secure connection\n            break;\n\n          case 'N':\n            // Server does not support SSL connections\n            self.stream.end();\n            return self.emit('error', new Error('The server does not support SSL connections'));\n\n          default:\n            // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n            self.stream.end();\n            return self.emit('error', new Error('There was an error establishing an SSL connection'));\n        }\n\n        var tls = require('tls');\n\n        var options = {\n          socket: self.stream\n        };\n\n        if (self.ssl !== true) {\n          Object.assign(options, self.ssl);\n\n          if ('key' in self.ssl) {\n            options.key = self.ssl.key;\n          }\n        }\n\n        if (net.isIP(host) === 0) {\n          options.servername = host;\n        }\n\n        try {\n          self.stream = tls.connect(options);\n        } catch (err) {\n          return self.emit('error', err);\n        }\n\n        self.attachListeners(self.stream);\n        self.stream.on('error', reportStreamError);\n        self.emit('sslconnect');\n      });\n    }\n  }, {\n    key: \"attachListeners\",\n    value: function attachListeners(stream) {\n      var _this2 = this;\n\n      stream.on('end', function () {\n        _this2.emit('end');\n      });\n      parse(stream, function (msg) {\n        var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n\n        if (_this2._emitMessage) {\n          _this2.emit('message', msg);\n        }\n\n        _this2.emit(eventName, msg);\n      });\n    }\n  }, {\n    key: \"requestSsl\",\n    value: function requestSsl() {\n      this.stream.write(serialize.requestSsl());\n    }\n  }, {\n    key: \"startup\",\n    value: function startup(config) {\n      this.stream.write(serialize.startup(config));\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(processID, secretKey) {\n      this._send(serialize.cancel(processID, secretKey));\n    }\n  }, {\n    key: \"password\",\n    value: function password(_password) {\n      this._send(serialize.password(_password));\n    }\n  }, {\n    key: \"sendSASLInitialResponseMessage\",\n    value: function sendSASLInitialResponseMessage(mechanism, initialResponse) {\n      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n    }\n  }, {\n    key: \"sendSCRAMClientFinalMessage\",\n    value: function sendSCRAMClientFinalMessage(additionalData) {\n      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(buffer) {\n      if (!this.stream.writable) {\n        return false;\n      }\n\n      return this.stream.write(buffer);\n    }\n  }, {\n    key: \"query\",\n    value: function query(text) {\n      this._send(serialize.query(text));\n    } // send parse message\n\n  }, {\n    key: \"parse\",\n    value: function parse(query) {\n      this._send(serialize.parse(query));\n    } // send bind message\n\n  }, {\n    key: \"bind\",\n    value: function bind(config) {\n      this._send(serialize.bind(config));\n    } // send execute message\n\n  }, {\n    key: \"execute\",\n    value: function execute(config) {\n      this._send(serialize.execute(config));\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.stream.writable) {\n        this.stream.write(flushBuffer);\n      }\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      this._ending = true;\n\n      this._send(flushBuffer);\n\n      this._send(syncBuffer);\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      this.stream.ref();\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      this.stream.unref();\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _this3 = this;\n\n      // 0x58 = 'X'\n      this._ending = true;\n\n      if (!this._connecting || !this.stream.writable) {\n        this.stream.end();\n        return;\n      }\n\n      return this.stream.write(endBuffer, function () {\n        _this3.stream.end();\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(msg) {\n      this._send(serialize.close(msg));\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(msg) {\n      this._send(serialize.describe(msg));\n    }\n  }, {\n    key: \"sendCopyFromChunk\",\n    value: function sendCopyFromChunk(chunk) {\n      this._send(serialize.copyData(chunk));\n    }\n  }, {\n    key: \"endCopyFrom\",\n    value: function endCopyFrom() {\n      this._send(serialize.copyDone());\n    }\n  }, {\n    key: \"sendCopyFail\",\n    value: function sendCopyFail(msg) {\n      this._send(serialize.copyFail(msg));\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter);\n\nmodule.exports = Connection;","map":{"version":3,"names":["net","require","EventEmitter","parse","serialize","flushBuffer","flush","syncBuffer","sync","endBuffer","end","Connection","config","stream","Socket","_keepAlive","keepAlive","_keepAliveInitialDelayMillis","keepAliveInitialDelayMillis","lastBuffer","parsedStatements","ssl","_ending","_emitMessage","self","on","eventName","port","host","_connecting","setNoDelay","connect","once","setKeepAlive","emit","reportStreamError","error","code","attachListeners","buffer","responseCode","toString","Error","tls","options","socket","Object","assign","key","isIP","servername","err","msg","name","write","requestSsl","startup","processID","secretKey","_send","cancel","password","mechanism","initialResponse","sendSASLInitialResponseMessage","additionalData","sendSCRAMClientFinalMessage","writable","text","query","bind","execute","ref","unref","close","describe","chunk","copyData","copyDone","copyFail","module","exports"],"sources":["C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/pg/lib/connection.js"],"sourcesContent":["'use strict'\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\n\nconst { parse, serialize } = require('pg-protocol')\n\nconst flushBuffer = serialize.flush()\nconst syncBuffer = serialize.sync()\nconst endBuffer = serialize.end()\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super()\n    config = config || {}\n    this.stream = config.stream || new net.Socket()\n    this._keepAlive = config.keepAlive\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n    this.lastBuffer = false\n    this.parsedStatements = {}\n    this.ssl = config.ssl || false\n    this._ending = false\n    this._emitMessage = false\n    var self = this\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true\n      }\n    })\n  }\n\n  connect(port, host) {\n    var self = this\n\n    this._connecting = true\n    this.stream.setNoDelay(true)\n    this.stream.connect(port, host)\n\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n      }\n      self.emit('connect')\n    })\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return\n      }\n      self.emit('error', error)\n    }\n    this.stream.on('error', reportStreamError)\n\n    this.stream.on('close', function () {\n      self.emit('end')\n    })\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream)\n    }\n\n    this.stream.once('data', function (buffer) {\n      var responseCode = buffer.toString('utf8')\n      switch (responseCode) {\n        case 'S': // Server supports SSL connections, continue with a secure connection\n          break\n        case 'N': // Server does not support SSL connections\n          self.stream.end()\n          return self.emit('error', new Error('The server does not support SSL connections'))\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end()\n          return self.emit('error', new Error('There was an error establishing an SSL connection'))\n      }\n      var tls = require('tls')\n      const options = {\n        socket: self.stream,\n      }\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl)\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key\n        }\n      }\n\n      if (net.isIP(host) === 0) {\n        options.servername = host\n      }\n      try {\n        self.stream = tls.connect(options)\n      } catch (err) {\n        return self.emit('error', err)\n      }\n      self.attachListeners(self.stream)\n      self.stream.on('error', reportStreamError)\n\n      self.emit('sslconnect')\n    })\n  }\n\n  attachListeners(stream) {\n    stream.on('end', () => {\n      this.emit('end')\n    })\n    parse(stream, (msg) => {\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n      if (this._emitMessage) {\n        this.emit('message', msg)\n      }\n      this.emit(eventName, msg)\n    })\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl())\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config))\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey))\n  }\n\n  password(password) {\n    this._send(serialize.password(password))\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false\n    }\n    return this.stream.write(buffer)\n  }\n\n  query(text) {\n    this._send(serialize.query(text))\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query))\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config))\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config))\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer)\n    }\n  }\n\n  sync() {\n    this._ending = true\n    this._send(flushBuffer)\n    this._send(syncBuffer)\n  }\n\n  ref() {\n    this.stream.ref()\n  }\n\n  unref() {\n    this.stream.unref()\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end()\n      return\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end()\n    })\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg))\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg))\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk))\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone())\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg))\n  }\n}\n\nmodule.exports = Connection\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}