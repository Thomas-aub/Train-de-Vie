{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar Result = require('./result');\n\nvar utils = require('./utils');\n\nvar Query = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Query, _EventEmitter);\n\n  var _super = _createSuper(Query);\n\n  function Query(config, values, callback) {\n    var _this;\n\n    _classCallCheck(this, Query);\n\n    _this = _super.call(this);\n    config = utils.normalizeQueryConfig(config, values, callback);\n    _this.text = config.text;\n    _this.values = config.values;\n    _this.rows = config.rows;\n    _this.types = config.types;\n    _this.name = config.name;\n    _this.binary = config.binary; // use unique portal name each time\n\n    _this.portal = config.portal || '';\n    _this.callback = config.callback;\n    _this._rowMode = config.rowMode;\n\n    if (process.domain && config.callback) {\n      _this.callback = process.domain.bind(config.callback);\n    }\n\n    _this._result = new Result(_this._rowMode, _this.types); // potential for multiple results\n\n    _this._results = _this._result;\n    _this.isPreparedStatement = false;\n    _this._canceledDueToError = false;\n    _this._promise = null;\n    return _this;\n  }\n\n  _createClass(Query, [{\n    key: \"requiresPreparation\",\n    value: function requiresPreparation() {\n      // named queries must always be prepared\n      if (this.name) {\n        return true;\n      } // always prepare if there are max number of rows expected per\n      // portal execution\n\n\n      if (this.rows) {\n        return true;\n      } // don't prepare empty text queries\n\n\n      if (!this.text) {\n        return false;\n      } // prepare if there are values\n\n\n      if (!this.values) {\n        return false;\n      }\n\n      return this.values.length > 0;\n    }\n  }, {\n    key: \"_checkForMultirow\",\n    value: function _checkForMultirow() {\n      // if we already have a result with a command property\n      // then we've already executed one query in a multi-statement simple query\n      // turn our results into an array of results\n      if (this._result.command) {\n        if (!Array.isArray(this._results)) {\n          this._results = [this._result];\n        }\n\n        this._result = new Result(this._rowMode, this.types);\n\n        this._results.push(this._result);\n      }\n    } // associates row metadata from the supplied\n    // message with this query object\n    // metadata used when parsing row results\n\n  }, {\n    key: \"handleRowDescription\",\n    value: function handleRowDescription(msg) {\n      this._checkForMultirow();\n\n      this._result.addFields(msg.fields);\n\n      this._accumulateRows = this.callback || !this.listeners('row').length;\n    }\n  }, {\n    key: \"handleDataRow\",\n    value: function handleDataRow(msg) {\n      var row;\n\n      if (this._canceledDueToError) {\n        return;\n      }\n\n      try {\n        row = this._result.parseRow(msg.fields);\n      } catch (err) {\n        this._canceledDueToError = err;\n        return;\n      }\n\n      this.emit('row', row, this._result);\n\n      if (this._accumulateRows) {\n        this._result.addRow(row);\n      }\n    }\n  }, {\n    key: \"handleCommandComplete\",\n    value: function handleCommandComplete(msg, connection) {\n      this._checkForMultirow();\n\n      this._result.addCommandComplete(msg); // need to sync after each command complete of a prepared statement\n      // if we were using a row count which results in multiple calls to _getRows\n\n\n      if (this.rows) {\n        connection.sync();\n      }\n    } // if a named prepared statement is created with empty query text\n    // the backend will send an emptyQuery message but *not* a command complete message\n    // since we pipeline sync immediately after execute we don't need to do anything here\n    // unless we have rows specified, in which case we did not pipeline the intial sync call\n\n  }, {\n    key: \"handleEmptyQuery\",\n    value: function handleEmptyQuery(connection) {\n      if (this.rows) {\n        connection.sync();\n      }\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(err, connection) {\n      // need to sync after error during a prepared statement\n      if (this._canceledDueToError) {\n        err = this._canceledDueToError;\n        this._canceledDueToError = false;\n      } // if callback supplied do not emit error event as uncaught error\n      // events will bubble up to node process\n\n\n      if (this.callback) {\n        return this.callback(err);\n      }\n\n      this.emit('error', err);\n    }\n  }, {\n    key: \"handleReadyForQuery\",\n    value: function handleReadyForQuery(con) {\n      if (this._canceledDueToError) {\n        return this.handleError(this._canceledDueToError, con);\n      }\n\n      if (this.callback) {\n        try {\n          this.callback(null, this._results);\n        } catch (err) {\n          process.nextTick(function () {\n            throw err;\n          });\n        }\n      }\n\n      this.emit('end', this._results);\n    }\n  }, {\n    key: \"submit\",\n    value: function submit(connection) {\n      if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n        return new Error('A query must have either text or a name. Supplying neither is unsupported.');\n      }\n\n      var previous = connection.parsedStatements[this.name];\n\n      if (this.text && previous && this.text !== previous) {\n        return new Error(\"Prepared statements must be unique - '\".concat(this.name, \"' was used for a different statement\"));\n      }\n\n      if (this.values && !Array.isArray(this.values)) {\n        return new Error('Query values must be an array');\n      }\n\n      if (this.requiresPreparation()) {\n        this.prepare(connection);\n      } else {\n        connection.query(this.text);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasBeenParsed\",\n    value: function hasBeenParsed(connection) {\n      return this.name && connection.parsedStatements[this.name];\n    }\n  }, {\n    key: \"handlePortalSuspended\",\n    value: function handlePortalSuspended(connection) {\n      this._getRows(connection, this.rows);\n    }\n  }, {\n    key: \"_getRows\",\n    value: function _getRows(connection, rows) {\n      connection.execute({\n        portal: this.portal,\n        rows: rows\n      }); // if we're not reading pages of rows send the sync command\n      // to indicate the pipeline is finished\n\n      if (!rows) {\n        connection.sync();\n      } else {\n        // otherwise flush the call out to read more rows\n        connection.flush();\n      }\n    } // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(connection) {\n      // prepared statements need sync to be called after each command\n      // complete or when an error is encountered\n      this.isPreparedStatement = true; // TODO refactor this poor encapsulation\n\n      if (!this.hasBeenParsed(connection)) {\n        connection.parse({\n          text: this.text,\n          name: this.name,\n          types: this.types\n        });\n      } // because we're mapping user supplied values to\n      // postgres wire protocol compatible values it could\n      // throw an exception, so try/catch this section\n\n\n      try {\n        connection.bind({\n          portal: this.portal,\n          statement: this.name,\n          values: this.values,\n          binary: this.binary,\n          valueMapper: utils.prepareValue\n        });\n      } catch (err) {\n        this.handleError(err, connection);\n        return;\n      }\n\n      connection.describe({\n        type: 'P',\n        name: this.portal || ''\n      });\n\n      this._getRows(connection, this.rows);\n    }\n  }, {\n    key: \"handleCopyInResponse\",\n    value: function handleCopyInResponse(connection) {\n      connection.sendCopyFail('No source stream defined');\n    } // eslint-disable-next-line no-unused-vars\n\n  }, {\n    key: \"handleCopyData\",\n    value: function handleCopyData(msg, connection) {// noop\n    }\n  }]);\n\n  return Query;\n}(EventEmitter);\n\nmodule.exports = Query;","map":{"version":3,"names":["require","EventEmitter","Result","utils","Query","config","values","callback","normalizeQueryConfig","text","rows","types","name","binary","portal","_rowMode","rowMode","process","domain","bind","_result","_results","isPreparedStatement","_canceledDueToError","_promise","length","command","Array","isArray","push","msg","_checkForMultirow","addFields","fields","_accumulateRows","listeners","row","parseRow","err","emit","addRow","connection","addCommandComplete","sync","con","handleError","nextTick","Error","previous","parsedStatements","requiresPreparation","prepare","query","_getRows","execute","flush","hasBeenParsed","parse","statement","valueMapper","prepareValue","describe","type","sendCopyFail","module","exports"],"sources":["C:/Users/thomas/Desktop/projet info/projet-rc1/node_modules/pg/lib/query.js"],"sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\n\nconst Result = require('./result')\nconst utils = require('./utils')\n\nclass Query extends EventEmitter {\n  constructor(config, values, callback) {\n    super()\n\n    config = utils.normalizeQueryConfig(config, values, callback)\n\n    this.text = config.text\n    this.values = config.values\n    this.rows = config.rows\n    this.types = config.types\n    this.name = config.name\n    this.binary = config.binary\n    // use unique portal name each time\n    this.portal = config.portal || ''\n    this.callback = config.callback\n    this._rowMode = config.rowMode\n    if (process.domain && config.callback) {\n      this.callback = process.domain.bind(config.callback)\n    }\n    this._result = new Result(this._rowMode, this.types)\n\n    // potential for multiple results\n    this._results = this._result\n    this.isPreparedStatement = false\n    this._canceledDueToError = false\n    this._promise = null\n  }\n\n  requiresPreparation() {\n    // named queries must always be prepared\n    if (this.name) {\n      return true\n    }\n    // always prepare if there are max number of rows expected per\n    // portal execution\n    if (this.rows) {\n      return true\n    }\n    // don't prepare empty text queries\n    if (!this.text) {\n      return false\n    }\n    // prepare if there are values\n    if (!this.values) {\n      return false\n    }\n    return this.values.length > 0\n  }\n\n  _checkForMultirow() {\n    // if we already have a result with a command property\n    // then we've already executed one query in a multi-statement simple query\n    // turn our results into an array of results\n    if (this._result.command) {\n      if (!Array.isArray(this._results)) {\n        this._results = [this._result]\n      }\n      this._result = new Result(this._rowMode, this.types)\n      this._results.push(this._result)\n    }\n  }\n\n  // associates row metadata from the supplied\n  // message with this query object\n  // metadata used when parsing row results\n  handleRowDescription(msg) {\n    this._checkForMultirow()\n    this._result.addFields(msg.fields)\n    this._accumulateRows = this.callback || !this.listeners('row').length\n  }\n\n  handleDataRow(msg) {\n    let row\n\n    if (this._canceledDueToError) {\n      return\n    }\n\n    try {\n      row = this._result.parseRow(msg.fields)\n    } catch (err) {\n      this._canceledDueToError = err\n      return\n    }\n\n    this.emit('row', row, this._result)\n    if (this._accumulateRows) {\n      this._result.addRow(row)\n    }\n  }\n\n  handleCommandComplete(msg, connection) {\n    this._checkForMultirow()\n    this._result.addCommandComplete(msg)\n    // need to sync after each command complete of a prepared statement\n    // if we were using a row count which results in multiple calls to _getRows\n    if (this.rows) {\n      connection.sync()\n    }\n  }\n\n  // if a named prepared statement is created with empty query text\n  // the backend will send an emptyQuery message but *not* a command complete message\n  // since we pipeline sync immediately after execute we don't need to do anything here\n  // unless we have rows specified, in which case we did not pipeline the intial sync call\n  handleEmptyQuery(connection) {\n    if (this.rows) {\n      connection.sync()\n    }\n  }\n\n  handleError(err, connection) {\n    // need to sync after error during a prepared statement\n    if (this._canceledDueToError) {\n      err = this._canceledDueToError\n      this._canceledDueToError = false\n    }\n    // if callback supplied do not emit error event as uncaught error\n    // events will bubble up to node process\n    if (this.callback) {\n      return this.callback(err)\n    }\n    this.emit('error', err)\n  }\n\n  handleReadyForQuery(con) {\n    if (this._canceledDueToError) {\n      return this.handleError(this._canceledDueToError, con)\n    }\n    if (this.callback) {\n      try {\n        this.callback(null, this._results)\n      }\n      catch(err) {\n        process.nextTick(() => {\n          throw err\n        })\n      }\n    }\n    this.emit('end', this._results)\n  }\n\n  submit(connection) {\n    if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n      return new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    }\n    const previous = connection.parsedStatements[this.name]\n    if (this.text && previous && this.text !== previous) {\n      return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n    }\n    if (this.values && !Array.isArray(this.values)) {\n      return new Error('Query values must be an array')\n    }\n    if (this.requiresPreparation()) {\n      this.prepare(connection)\n    } else {\n      connection.query(this.text)\n    }\n    return null\n  }\n\n  hasBeenParsed(connection) {\n    return this.name && connection.parsedStatements[this.name]\n  }\n\n  handlePortalSuspended(connection) {\n    this._getRows(connection, this.rows)\n  }\n\n  _getRows(connection, rows) {\n    connection.execute({\n      portal: this.portal,\n      rows: rows,\n    })\n    // if we're not reading pages of rows send the sync command\n    // to indicate the pipeline is finished\n    if (!rows) {\n      connection.sync()\n    } else {\n      // otherwise flush the call out to read more rows\n      connection.flush()\n    }\n  }\n\n  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n  prepare(connection) {\n    // prepared statements need sync to be called after each command\n    // complete or when an error is encountered\n    this.isPreparedStatement = true\n\n    // TODO refactor this poor encapsulation\n    if (!this.hasBeenParsed(connection)) {\n      connection.parse({\n        text: this.text,\n        name: this.name,\n        types: this.types,\n      })\n    }\n\n    // because we're mapping user supplied values to\n    // postgres wire protocol compatible values it could\n    // throw an exception, so try/catch this section\n    try {\n      connection.bind({\n        portal: this.portal,\n        statement: this.name,\n        values: this.values,\n        binary: this.binary,\n        valueMapper: utils.prepareValue,\n      })\n    } catch (err) {\n      this.handleError(err, connection)\n      return\n    }\n\n    connection.describe({\n      type: 'P',\n      name: this.portal || '',\n    })\n\n    this._getRows(connection, this.rows)\n  }\n\n  handleCopyInResponse(connection) {\n    connection.sendCopyFail('No source stream defined')\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  handleCopyData(msg, connection) {\n    // noop\n  }\n}\n\nmodule.exports = Query\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}